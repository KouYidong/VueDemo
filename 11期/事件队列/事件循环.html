<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>事件循环</title>
</head>
<body>
  <script>
  /* 
    js只有一个主线程，同步任务在主线程中执行，
    异步任务进入事件表并通过事件表注册回调函数，并将回调函数压入事件队列，
    当主线程中为空的时候会去检查事件队列，如果为空则继续检查，
    反之将事件队列中首部的回调函数压入执行栈（主线程）并执行
    检查执行栈，如果为空则检查事件队列，反之继续检查执行栈

    循环的过程就是事件循环（EvenLoop）
   */

   /* 
    为什么会有异步：
      1. 后台代码出现延迟的话会有阻塞，所以需要用异步来解决
    在ajax请求的同时，可以去做其他的工作，便有了事件循环
    */

    /* ***************什么是事件队列***************** */
    console.log('start');
    setTimeout(function() {
      console.log('setTimeout');
    }, 1000);
    console.log('end');
    /* 
      程序的执行顺序：start、end、setTimeout
      事件队列：
        一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在前边的会先执行，而在队尾的后执行，
        事件队列每次只执行一个任务，在该任务执行完毕之后再执行下一个任务。
      主线程执行栈：
        一个类似于函数调用栈的运行容器，当执行栈为空时，JS引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。
     */

    /* ***************事件队列的作用***************** */

      /* 
      js引擎如何执行js代码：
        js事件循环机制：
          1. 检查执行栈，如果为空则执行第2步，不为空继续检查
          2. 检查事件队列是否为空，如果为空继续检查，如果不为空则执行3
          3. 取出事件队列的第一个，压入执行栈
          4. 执行任务，执行完之后返回第1步
      */

     /* 
      ajax技术的同步性和异步性：
        通过事件循环机制，我们不需要等待ajax响应之后再进行工作，
        我们设置一个回调函数，将ajax请求挂起，然后继续执行后边的代码，
        即使请求永远不响应也不会阻塞代码，而当响应成功之后，浏览器的时间表会将回调函数添加到实践队列中等待执行。
        事件监听器的回调函数也是一个任务，当我们注册了事件监听器之后，浏览器的事件表会进行登记，当触发事件时，
        事件表便将回调函数添加至事件队列中。
      */
      /* 
        动画的生成，就是利用事件循环，在事件循环过程中没有阻塞页面渲染，这就保证了用户在浏览页面时不会出现阻塞。
       */
       /* 
        事件循环的注意点：
          1. 事件队列严格按照时间先后顺序将任务压入执行栈执行
          2. 当执行栈为空时，浏览器会不停的检查事件队列，如果不为空，则取出第一个任务
          3. 在每一个任务结束之后，浏览器就会对页面进行渲染。
        */
  </script>
</body>
</html>